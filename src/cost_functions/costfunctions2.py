#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
#  robustcostfunctions.py
#
#  Copyright 2018 Anupam Mitra <anupam@unm.edu>
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#
#

from __future__ import division

import itertools
import numpy as np
import timeevolve

def infidelity (control_variables, \
    static_parameters, target, ndim, hamiltonian_function, tsteps, weights, \
    full_unitary_function=None):
    """
    Computes the mean infidelity for a control task for given values of the
    control variables

    Parameters Needed
    -----------------
    control_variables: ndarray <real> (ncontrols, nsteps)
    Values of the control variables at which to evaluate the infidelity
    and the gradient of the infidelity

    static_parameters: ndarray <real> (nparameters, nlandmarks)
    Values of the static parameters for the Hamiltonian, that may vary across
    different landmark points. These are typically kept constant and may be
    subject to experimental uncertainty

    target: ndarray <complex> (ndim, ndim)
    Target unitary transformation to be implemented

    ndim: integer
    Dimension of the Hilbert space

    hamiltonian_function: function
    Python function which computes the Hamiltonian and its gradient, taking
    input control_variables and static parameters

    tsteps: ndarray <real> (nsteps)
    Duration of time steps

    weights: ndarray <real> (nlandmarks)
    Weights of each landmark point

    full_unitary_function: function
    Python function which computes the full unitary transformation. The target
    unitary transformations may involve a sequence of many unitary
    transformations, one of which is unitary transformation generated by the
    optimal control
    For example:
    The dress, control, undress protocol
    u = u_undress * u_control * u_dress
    u = (u_undress * u_control * u_dress) * u_echopulse
       * (u_undress * u_control * u_dress)

    Parameters
    ----------
    control_variables:
    Values of the control variables at which to evaluate the
    gradient of the propagator

    control_params:
    Dictionary representing parameters of the control problem
    with the following keys

    Returns
    -------
    infidelity_mean:
    Infidelity = 1 - fidelity evaluated at given values of the control
    variables, averaged over all inhomogeneities

    grad_infidelity_mean:
    Gradient of the infidelity with respect to the control variables
    averaged over all inhomogeneities
    """

    ncontrols, nsteps = np.shape(control_variables)
    nparameters, nlandmarks = np.shape(static_parameters)

    hamiltonians = np.empty((ndim, ndim, nlandmarks, nsteps))
    grad_hamiltonians = np.empty((ndim, ndim, nlandmarks, nsteps, ncontrols))

    ndimtarget = np.linalg.matrix_rank(target)

    # Compute the stepwise constant Hamiltonian and its gradient
    for l in range(nlandmarks):
        t = 0
        for s in range(nsteps):
            h, dh = hamiltonian_function(\
                    control_variables[:, s], static_parameters[:, l], \
                    t, jacobian=True, hessian=False)
            hamiltonians[:, :, s, l] = h
            for k in range(ncontrols):
                grad_hamiltonians[:, :, l, s, k] = dh[:, :, s, k]

            t = t + tsteps[s]

    # Compute the control propagator
    u_control, grad_u_control = timeevolve.calc_time_evolve_op(\
            hamiltonians, grad_hamiltonians, tsteps, ndim)

    # Compute the unitary transformation
    if full_unitary_function != None:
        u, grad_u = full_unitary_function (u_control, grad_u_control)
    else:
        u, grad_u = u_control, grad_u_control

    # Compute the infidelity at each landmark point
    goal = np.zeros((nlandmarks,), dtype=complex)
    infidelity = np.zeros(np.shape(goal))

    grad_goal = np.zeros((nlandmarks, nsteps, ncontrols), dtype=complex)
    grad_infidelity = np.zeros(np.shape(grad_goal))

    for l in range(nlandmarks):
        goal[l] = np.trace(np.dot(u[:, :, l, nsteps, 0], dagger(target)))
        infidelity[l] = 1 - 1/(ndimtarget*ndimtarget) * np.abs(goal[l])**2

        for k in range(ncontrols):
            for s in range(nsteps):
                grad_goal[l, s, k] = np.trace(\
                    np.dot(grad_u[:, :, l, nsteps, 0, s, k], dagger(target)))

                grad_infidelity[l, s, k] += - 2/(ndimtarget*ndimtarget) \
                    * np.real(grad_goal[l, s, k] * np.conjugate(goal[l]))

    # Average the infidelity over landmark points
    infidelity_mean = np.sum(infidelity * weights, axis=0)/nlandmarks
    grad_infidelity_mean = np.sum(grad_infidelity * weights, axis=0)/nlandmarks

    return infidelity_mean, np.reshape(grad_infidelity_mean, (nsteps,))
